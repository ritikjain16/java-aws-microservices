# name: CI / CD — Build → DevSecOps → ECR → GitOps (ArgoCD)

# # Run on push to main (customize branches) and PRs
# on:
#     push:
#         branches: ["master"]
#     pull_request:
#         branches: ["master"]
#     workflow_dispatch:

# permissions:
#     contents: write
#     id-token: write # required for OIDC to AWS
#     issues: write
#     pull-requests: write

# # env:
# #   APP_NAME: my-app
# #   IMAGE_REPO: 123456789012.dkr.ecr.${{ secrets.AWS_REGION1 }}.amazonaws.com/${{ env.APP_NAME }}
# #   MANIFEST_PATH: k8s/overlays/prod # path to k8s manifests in repo to update
# #   TAG: ${{ github.sha }}-$({{ github.run_number }})

# env:
#     APP_NAME: java-aws-microservice-app
#     MANIFEST_PATH: k8s
#     TAG: ${{ github.sha }}-${{ github.run_number }}
#     IMAGE_REPO: ${{secrets.AWS_ACCOUNT_ID1}}.dkr.ecr.${{ secrets.AWS_REGION1 }}.amazonaws.com/my-app

# jobs:
#     # build:
#     #   runs-on: ubuntu-latest
#     #   steps:
#     #     - name: Set IMAGE_REPO
#     #       run: echo "IMAGE_REPO=${{secrets.AWS_ACCOUNT_ID1}}.dkr.ecr.${{ secrets.AWS_REGION1 }}.amazonaws.com/${{ env.APP_NAME }}" >> $GITHUB_ENV

#     # jobs:
#     # 1. Checkout + cache dependencies (lightweight)
#     checkout:
#         name: Checkout + Cache
#         runs-on: ubuntu-latest
#         outputs:
#             commit: ${{ steps.commit.outputs.sha }}
#         steps:
#             - name: Checkout repo
#               uses: actions/checkout@v4
#               with:
#                   fetch-depth: 0

#             - name: Set commit output
#               id: commit
#               run: echo "::set-output name=sha::${GITHUB_SHA}"

#             - name: Check for package.json
#               id: check_node
#               run: |
#                   if [ -f package.json ]; then
#                     echo "exists=true" >> $GITHUB_OUTPUT
#                   else
#                     echo "exists=false" >> $GITHUB_OUTPUT
#                   fi
#               shell: bash

#             - name: Setup Node cache
#               if: steps.check_node.outputs.exists == 'true'
#               uses: actions/cache@v4
#               with:
#                   path: |
#                       **/node_modules
#                       ~/.npm
#                   key: ${{ runner.os }}-npm-${{ hashFiles('**/package-lock.json') }}
#                   restore-keys: |
#                       ${{ runner.os }}-npm-

#             - name: Check for Maven/Gradle files
#               id: check_java
#               run: |
#                   if [ -f pom.xml ] || [ -f build.gradle ]; then
#                     echo "exists=true" >> $GITHUB_OUTPUT
#                   else
#                     echo "exists=false" >> $GITHUB_OUTPUT
#                   fi

#             - name: Setup Maven/Gradle cache
#               if: steps.check_java.outputs.exists == 'true'
#               uses: actions/cache@v4
#               with:
#                   path: |
#                       ~/.m2/repository
#                       ~/.gradle/caches
#                       ~/.gradle/wrapper
#                   key: ${{ runner.os }}-build-${{ hashFiles('**/pom.xml', '**/build.gradle*') }}
#                   restore-keys: |
#                       ${{ runner.os }}-build-

#             # - name: Setup Node cache
#             #   if: exists('package.json')
#             #   uses: actions/cache@v4
#             #   with:
#             #     path: |
#             #       **/node_modules
#             #       ~/.npm
#             #     key: ${{ runner.os }}-npm-${{ hashFiles('**/package-lock.json') }}
#             #     restore-keys: |
#             #       ${{ runner.os }}-npm-

#             # - name: Setup Maven/Gradle cache
#             #   if: exists('pom.xml') || exists('build.gradle')
#             #   uses: actions/cache@v4
#             #   with:
#             #     path: |
#             #       ~/.m2/repository
#             #       ~/.gradle/caches
#             #       ~/.gradle/wrapper
#             #     key: ${{ runner.os }}-build-${{ hashFiles('**/pom.xml','**/build.gradle*') }}
#             #     restore-keys: |
#             #       ${{ runner.os }}-build-

#     # 2. Build & Unit Tests (language-specific)
#     build-and-test:
#         name: Build & Unit Tests
#         runs-on: ubuntu-latest
#         needs: checkout
#         strategy:
#             matrix:
#                 # If multi-language repo, you can expand. Keep single-run for simplicity.
#                 include:
#                     - lang: node
#         steps:
#             - name: Checkout
#               uses: actions/checkout@v4

#             - name: Use Node.js
#               if: matrix.lang == 'node'
#               uses: actions/setup-node@v4
#               with:
#                   node-version: 18

#             - name: Install dependencies & run tests
#               if: matrix.lang == 'node'
#               run: |
#                   npm ci
#                   npm test --if-present

#             - name: Archive build artifacts
#               if: always()
#               uses: actions/upload-artifact@v4
#               with:
#                   name: build-artifact
#                   path: |
#                       dist/** || build/** || target/** || .

#     # 3. Static Code Analysis (SonarQube)
#     sonar:
#         name: SonarQube scan & quality gate
#         runs-on: ubuntu-latest
#         needs: build-and-test
#         steps:
#             - name: Setup JDK (Sonar Scanner requirement)
#               uses: actions/setup-java@v4
#               with:
#                   distribution: temurin
#                   java-version: "17"

#             - name: Install Sonar Scanner CLI
#               run: |
#                   wget https://binaries.sonarsource.com/Distribution/sonar-scanner-cli/sonar-scanner-cli-5.0.1.3006-linux.zip
#                   unzip sonar-scanner-cli-5.0.1.3006-linux.zip
#                   echo "$PWD/sonar-scanner-5.0.1.3006-linux/bin" >> $GITHUB_PATH

#             - name: Run SonarQube analysis
#               env:
#                   SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL1 }}
#                   SONAR_TOKEN: ${{ secrets.SONAR_TOKEN1 }}
#               run: |
#                   # template: adapt to your build tool (mvn/gradle/npm)
#                   sonar-scanner \
#                     -Dsonar.projectKey=${{ env.APP_NAME }} \
#                     -Dsonar.host.url=${{ secrets.SONAR_HOST_URL1 }} \
#                     -Dsonar.login=${{ secrets.SONAR_TOKEN1 }} \
#                     -Dsonar.inclusions=**/*.js,**/*.ts,**/*.jsx,**/*.css
#                     # -Dsonar.sources=mern-app-aws-frontend/src \
#             - name: Wait for SonarQube Quality Gate (fail if gate fails)
#               env:
#                   SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL1 }}
#                   SONAR_TOKEN: ${{ secrets.SONAR_TOKEN1 }}
#               run: |
#                   echo "Waiting for SonarQube Quality Gate result..."

#                   # Wait for the analysis report to be processed
#                   analysisId=$(grep 'ceTaskId' .scannerwork/report-task.txt | cut -d'=' -f2)
#                   echo "Analysis ID: $analysisId"

#                   # Poll SonarQube API until the analysis is complete
#                   status="PENDING"
#                   for i in {1..30}; do
#                     sleep 5
#                     status=$(curl -s -u $SONAR_TOKEN: "$SONAR_HOST_URL/api/ce/task?id=$analysisId" | jq -r '.task.status')
#                     echo "Current Status: $status"
#                     if [ "$status" == "SUCCESS" ]; then
#                       break
#                     elif [ "$status" == "FAILED" ]; then
#                       echo "SonarQube analysis failed."
#                       exit 1
#                     fi
#                   done

#                   if [ "$status" != "SUCCESS" ]; then
#                     echo "SonarQube analysis did not complete in time."
#                     exit 1
#                   fi

#                   # Fetch Quality Gate result
#                   analysisKey=$(curl -s -u $SONAR_TOKEN: "$SONAR_HOST_URL/api/ce/task?id=$analysisId" | jq -r '.task.analysisId')
#                   echo "Analysis Key: $analysisKey"

#                   qualityGateStatus=$(curl -s -u $SONAR_TOKEN: "$SONAR_HOST_URL/api/qualitygates/project_status?analysisId=$analysisKey" | jq -r '.projectStatus.status')
#                   echo "Quality Gate Status: $qualityGateStatus"

#                   if [ "$qualityGateStatus" != "OK" ]; then
#                     echo "Quality Gate failed."
#                     exit 1
#                   else
#                     echo "Quality Gate passed."
#                   fi

#     dependency-check:
#         name: OWASP Dependency Check
#         runs-on: ubuntu-latest
#         needs: build-and-test
#         steps:
#             - name: Checkout code
#               uses: actions/checkout@v4

#             # - name: Set up Java (Dependency-Check requirement)
#             #   uses: actions/setup-java@v4
#             #   with:
#             #     distribution: temurin
#             #     java-version: "17"

#             - name: Run OWASP Dependency-Check
#               uses: dependency-check/Dependency-Check_Action@main
#               with:
#                   project: "mern-app-aws" # ✅ your project name (can be anything)
#                   path: "." # ✅ path to scan (use . for repo root)
#                   format: "ALL" # ✅ generate all report types (HTML, JSON, XML, SARIF)
#                   args: >
#                       --enableExperimental
#                       --failOnCVSS 8                 # optional: specify suppression XML if you have one
#                   out: reports

#             - name: Upload Dependency-Check report
#               uses: actions/upload-artifact@v4
#               with:
#                   name: dependency-check-report
#                   path: reports/

#     # 5. Build Docker image (and produce an image tar as artifact)
#     build-image:
#         name: Build Docker image
#         runs-on: ubuntu-latest
#         needs: [checkout, build-and-test]
#         outputs:
#             image-tag: ${{ steps.tag.outputs.IMAGE_TAG }}
#         steps:
#             - name: Checkout
#               uses: actions/checkout@v4

#             - name: Set image tag
#               id: tag
#               run: |
#                   IMAGE_TAG=${GITHUB_SHA::8}
#                   echo "IMAGE_TAG=$IMAGE_TAG" >> $GITHUB_OUTPUT
#                   echo "IMAGE_FULL=${{ env.IMAGE_REPO }}:${IMAGE_TAG}" >> $GITHUB_OUTPUT

#             - name: Login to Amazon ECR (uses OIDC / short-lived creds)
#               uses: aws-actions/configure-aws-credentials@v3
#               with:
#                   role-to-assume: ${{ secrets.AWS_OIDC_ROLE_ARN1 }} # least-privilege role configured in AWS for repo
#                   aws-region: ${{ secrets.AWS_REGION1 }}

#             - name: Configure Docker to use ECR credentials
#               run: |
#                   # aws ecr get-login-password --region ${{ secrets.AWS_REGION1 }} | docker login --username AWS --password-stdin ${{ env.IMAGE_REPO }}
#                   aws ecr get-login-password --region ${{ secrets.AWS_REGION1 }} | docker login --username AWS --password-stdin ${{secrets.AWS_ACCOUNT_ID1}}.dkr.ecr.${{ secrets.AWS_REGION1 }}.amazonaws.com

#             - name: Build Docker image
#               run: |
#                   docker build --pull -t ${{ env.IMAGE_REPO }}:${{ steps.tag.outputs.IMAGE_TAG }} .
#                   docker tag ${{ env.IMAGE_REPO }}:${{ steps.tag.outputs.IMAGE_TAG }} ${{ env.IMAGE_REPO }}:latest
#                   docker push ${{ env.IMAGE_REPO }}:${{ steps.tag.outputs.IMAGE_TAG }}

#             - name: Save image metadata (for downstream)
#               run: echo "${{ env.IMAGE_REPO }}:${{ steps.tag.outputs.IMAGE_TAG }}" > image_info.txt

#             - name: Upload image metadata
#               uses: actions/upload-artifact@v4
#               with:
#                   name: image-info
#                   path: image_info.txt

#     # 6. Container Image Scanning (Trivy)
#     trivy-scan:
#         name: Trivy image scan
#         runs-on: ubuntu-latest
#         needs: build-image
#         steps:
#             - name: Download image metadata
#               uses: actions/download-artifact@v4
#               with:
#                   name: image-info
#                   path: .

#             - name: Read image name
#               id: read
#               run: |
#                   IMAGE=$(cat image_info.txt)
#                   echo "image=$IMAGE" >> $GITHUB_OUTPUT
#             - name: Show parsed image (debug)
#               run: echo "IMAGE='${{ steps.read.outputs.image }}'"

#             - name: Login to Amazon ECR (uses OIDC / short-lived creds)
#               uses: aws-actions/configure-aws-credentials@v3
#               with:
#                   role-to-assume: ${{ secrets.AWS_OIDC_ROLE_ARN1 }} # least-privilege role configured in AWS for repo
#                   aws-region: ${{ secrets.AWS_REGION1 }}

#             - name: ECR credentials for trivy
#               run: |
#                   # aws ecr get-login-password --region ${{ secrets.AWS_REGION1 }} | docker login --username AWS --password-stdin ${{ env.IMAGE_REPO }}
#                   aws ecr get-login-password --region ${{ secrets.AWS_REGION1 }} | docker login --username AWS --password-stdin ${{secrets.AWS_ACCOUNT_ID1}}.dkr.ecr.${{ secrets.AWS_REGION1 }}.amazonaws.com

#             - name: Run Trivy scan
#               uses: aquasecurity/trivy-action@0.28.0
#               with:
#                   image-ref: ${{ steps.read.outputs.image }}
#                   format: json
#                   #  json: "severity: {{range .Results}}{{.Vulnerabilities}}{{end}}"
#                   exit-code: "1" # Fail if vulnerabilities found
#               env:
#                   GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

#             - name: Upload Trivy report
#               if: always()
#               uses: actions/upload-artifact@v4
#               with:
#                   name: trivy-report
#                   path: ./

#     # 7. Push to ECR (only on main branch; gated by previous steps)

#     # 8. Update Git manifest (so ArgoCD can pick new image) -> two patterns supported
#     update-manifest-and-git:
#         name: Update k8s manifests & push commit (GitOps)
#         runs-on: ubuntu-latest
#         needs: trivy-scan
#         if: github.ref == 'refs/heads/master'
#         steps:
#             - name: Checkout (full history)
#               uses: actions/checkout@v4
#               with:
#                   fetch-depth: 0
#                   token: ${{ secrets.GITHUB_TOKEN }}

#             - name: Download image metadata
#               uses: actions/download-artifact@v4
#               with:
#                   name: image-info
#                   path: .

#             - name: Read image name
#               id: read
#               run: |
#                   IMAGE=$(cat image_info.txt)
#                   echo "image=$IMAGE" >> $GITHUB_OUTPUT

#             - name: Show parsed image (debug)
#               run: echo "IMAGE='${{ steps.read.outputs.image }}'"

#             #- name: Download image info
#             #uses: actions/download-artifact@v4
#             # with:
#             #name: image-deploy-info
#             # path: .

#         #   - name: Update manifests with new image tag
#         #     run: |
#         #       git pull
#         #       #IMAGE=$(grep IMAGE image_deploy_info.txt | cut -d'=' -f2)
#         #       # Example: replace image tag in k8s deployment yaml (tweak path & sed for your YAML structure)
#         #       # find ${{ env.MANIFEST_PATH }} -type f -name '*.yaml' -print0 | xargs -0
#         #       sed -i -e "s|image: .*|image: ${{ steps.read.outputs.image }}|g" k8s/deployment.yml
#         #       git config user.name "github-actions[bot]"
#         #       git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
#         #       git add ${{ env.MANIFEST_PATH }}
#         #       git commit -m "chore: release ${IMAGE} [skip ci]" || echo "no changes to commit"

#         #   - name: Push commit with updated manifest
#         #     run: |
#         #       git push -u origin master
#         #   #- name: (optional) Create Git tag
#         #    # run: |
#         #     #  IMAGE_TAG=$(basename $(grep IMAGE image_deploy_info.txt | cut -d':' -f2))
#         #     #  git tag -a "release-${IMAGE_TAG}" -m "release ${IMAGE_TAG}"
#         #      # git push origin "release-${IMAGE_TAG}" || true
# #   # 9. (Optional) Notify ArgoCD to sync immediately via CLI or API
# #   argocd-notify:
# #     name: Trigger ArgoCD sync (optional)
# #     runs-on: ubuntu-latest
# #     needs: update-manifest-and-git
# #     if: github.ref == 'refs/heads/main'
# #     steps:
# #       - name: Call ArgoCD API to trigger sync
# #         env:
# #           ARGOCD_HOST: ${{ secrets.ARGOCD_HOST }}
# #           ARGOCD_TOKEN: ${{ secrets.ARGOCD_TOKEN }}
# #         run: |
# #           # Use argocd CLI or API. Example using curl:
# #           APP_NAME="my-app"
# #           curl -k -H "Authorization: Bearer $ARGOCD_TOKEN" \
# #             -X POST "https://${ARGOCD_HOST}/api/v1/applications/${APP_NAME}/sync"

# # NOTE: Alternatively, recommend Argo CD Image Updater (instead of update-manifest-and-git)
# # See docs: https://argocd-image-updater.readthedocs.io/
