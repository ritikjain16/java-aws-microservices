name: CI / CD — Build → DevSecOps → ECR → GitOps (ArgoCD)

# Run on push to main (customize branches) and PRs
on:
    push:
        branches: ["master"]
    pull_request:
        branches: ["master"]
    workflow_dispatch:

env:
    ECR_REGISTRY: ${{secrets.AWS_ACCOUNT_ID1}}.dkr.ecr.${{ secrets.AWS_REGION1 }}.amazonaws.com
    API_GATEWAY_REPO: api-gateway
    EUREKA_REPO: eureka-server
    USER_SERVICE_REPO: user-service
    ORDER_SERVICE_REPO: order-service

permissions:
    contents: write
    id-token: write # required for OIDC to AWS
    issues: write
    pull-requests: write

jobs:
    checkout:
        name: Checkout + Cache
        runs-on: ubuntu-latest
        outputs:
            commit: ${{ steps.commit.outputs.sha }}
        steps:
            - name: Checkout repo
              uses: actions/checkout@v4
              with:
                  fetch-depth: 0

            - name: Set commit output
              id: commit
              run: echo "sha=${GITHUB_SHA}" >> $GITHUB_OUTPUT

    # # 3. Static Code Analysis (SonarQube)
    # sonar:
    #     name: SonarQube scan & quality gate
    #     runs-on: ubuntu-latest
    #     needs: checkout
    #     steps:
    #         - name: Setup JDK (Sonar Scanner requirement)
    #           uses: actions/setup-java@v4
    #           with:
    #               distribution: temurin
    #               java-version: "17"

    #         - name: Install Sonar Scanner CLI
    #           run: |
    #               wget https://binaries.sonarsource.com/Distribution/sonar-scanner-cli/sonar-scanner-cli-5.0.1.3006-linux.zip
    #               unzip sonar-scanner-cli-5.0.1.3006-linux.zip
    #               echo "$PWD/sonar-scanner-5.0.1.3006-linux/bin" >> $GITHUB_PATH

    #         - name: Run SonarQube analysis
    #           env:
    #               SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL1 }}
    #               SONAR_TOKEN: ${{ secrets.SONAR_TOKEN1 }}
    #           run: |
    #               # template: adapt to your build tool (mvn/gradle/npm)
    #               sonar-scanner \
    #                   -Dsonar.projectKey=${{ env.APP_NAME }} \
    #                   -Dsonar.host.url=${{ secrets.SONAR_HOST_URL1 }} \
    #                   -Dsonar.login=${{ secrets.SONAR_TOKEN1 }} \
    #                   -Dsonar.inclusions=**/*.js,**/*.ts,**/*.jsx,**/*.css
    #                   # -Dsonar.sources=mern-app-aws-frontend/src \
    #         - name: Wait for SonarQube Quality Gate (fail if gate fails)
    #           env:
    #               SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL1 }}
    #               SONAR_TOKEN: ${{ secrets.SONAR_TOKEN1 }}
    #           run: |
    #               echo "Waiting for SonarQube Quality Gate result..."

    #               # Wait for the analysis report to be processed
    #               analysisId=$(grep 'ceTaskId' .scannerwork/report-task.txt | cut -d'=' -f2)
    #               echo "Analysis ID: $analysisId"

    #               # Poll SonarQube API until the analysis is complete
    #               status="PENDING"
    #               for i in {1..30}; do
    #                   sleep 5
    #                   status=$(curl -s -u $SONAR_TOKEN: "$SONAR_HOST_URL/api/ce/task?id=$analysisId" | jq -r '.task.status')
    #                   echo "Current Status: $status"
    #                   if [ "$status" == "SUCCESS" ]; then
    #                   break
    #                   elif [ "$status" == "FAILED" ]; then
    #                   echo "SonarQube analysis failed."
    #                   exit 1
    #                   fi
    #               done

    #               if [ "$status" != "SUCCESS" ]; then
    #                   echo "SonarQube analysis did not complete in time."
    #                   exit 1
    #               fi

    #               # Fetch Quality Gate result
    #               analysisKey=$(curl -s -u $SONAR_TOKEN: "$SONAR_HOST_URL/api/ce/task?id=$analysisId" | jq -r '.task.analysisId')
    #               echo "Analysis Key: $analysisKey"

    #               qualityGateStatus=$(curl -s -u $SONAR_TOKEN: "$SONAR_HOST_URL/api/qualitygates/project_status?analysisId=$analysisKey" | jq -r '.projectStatus.status')
    #               echo "Quality Gate Status: $qualityGateStatus"

    #               if [ "$qualityGateStatus" != "OK" ]; then
    #                   echo "Quality Gate failed."
    #                   exit 1
    #               else
    #                   echo "Quality Gate passed."
    #               fi

    build-api-gateway:
        name: Build & Push API Gateway
        runs-on: ubuntu-latest
        needs: checkout
        steps:
            - uses: actions/checkout@v4
            - uses: aws-actions/configure-aws-credentials@v3
              with:
                  role-to-assume: ${{ secrets.AWS_OIDC_ROLE_ARN1 }}
                  aws-region: ${{ secrets.AWS_REGION1 }}
            - uses: aws-actions/amazon-ecr-login@v1
            - name: Configure Docker to use ECR credentials
              run: |
                  aws ecr get-login-password --region ${{ secrets.AWS_REGION1 }} | docker login --username AWS --password-stdin ${{secrets.AWS_ACCOUNT_ID1}}.dkr.ecr.${{ secrets.AWS_REGION1 }}.amazonaws.com
            - name: Build and push
              run: |
                  TAG=${{ needs.checkout.outputs.commit }}-${{ github.run_number }}
                  IMAGE=${{ env.ECR_REGISTRY }}/${{ env.API_GATEWAY_REPO }}:$TAG
                  echo "Building image: $IMAGE"
                  docker build -t $IMAGE ./api-gateway
                  docker push $IMAGE

    build-eureka-server:
        name: Build & Push Eureka Server
        runs-on: ubuntu-latest
        needs: checkout
        steps:
            - uses: actions/checkout@v4
            - uses: aws-actions/configure-aws-credentials@v3
              with:
                  role-to-assume: ${{ secrets.AWS_OIDC_ROLE_ARN1 }}
                  aws-region: ${{ secrets.AWS_REGION1 }}
            - uses: aws-actions/amazon-ecr-login@v1
            - name: Configure Docker to use ECR credentials
              run: |
                  aws ecr get-login-password --region ${{ secrets.AWS_REGION1 }} | docker login --username AWS --password-stdin ${{secrets.AWS_ACCOUNT_ID1}}.dkr.ecr.${{ secrets.AWS_REGION1 }}.amazonaws.com
            - name: Build and push
              run: |
                  TAG=${{ needs.checkout.outputs.commit }}-${{ github.run_number }}
                  IMAGE=${{ env.ECR_REGISTRY }}/${{ env.EUREKA_REPO }}:$TAG
                  echo "Building image: $IMAGE"
                  docker build -t $IMAGE ./eureka-server
                  docker push $IMAGE

    build-user-service:
        name: Build & Push User Service
        runs-on: ubuntu-latest
        needs: checkout
        steps:
            - uses: actions/checkout@v4
            - uses: aws-actions/configure-aws-credentials@v3
              with:
                  role-to-assume: ${{ secrets.AWS_OIDC_ROLE_ARN1 }}
                  aws-region: ${{ secrets.AWS_REGION1 }}
            - uses: aws-actions/amazon-ecr-login@v1
            - name: Configure Docker to use ECR credentials
              run: |
                  aws ecr get-login-password --region ${{ secrets.AWS_REGION1 }} | docker login --username AWS --password-stdin ${{secrets.AWS_ACCOUNT_ID1}}.dkr.ecr.${{ secrets.AWS_REGION1 }}.amazonaws.com
            - name: Build and push
              run: |
                  TAG=${{ needs.checkout.outputs.commit }}-${{ github.run_number }}
                  IMAGE=${{ env.ECR_REGISTRY }}/${{ env.USER_SERVICE_REPO }}:$TAG
                  echo "Building image: $IMAGE"
                  docker build -t $IMAGE ./user-service
                  docker push $IMAGE

    build-order-service:
        name: Build & Push Order Service
        runs-on: ubuntu-latest
        needs: checkout
        steps:
            - uses: actions/checkout@v4
            - uses: aws-actions/configure-aws-credentials@v3
              with:
                  role-to-assume: ${{ secrets.AWS_OIDC_ROLE_ARN1 }}
                  aws-region: ${{ secrets.AWS_REGION1 }}
            - uses: aws-actions/amazon-ecr-login@v1
            - name: Configure Docker to use ECR credentials
              run: |
                  aws ecr get-login-password --region ${{ secrets.AWS_REGION1 }} | docker login --username AWS --password-stdin ${{secrets.AWS_ACCOUNT_ID1}}.dkr.ecr.${{ secrets.AWS_REGION1 }}.amazonaws.com
            - name: Build and push
              run: |
                  TAG=${{ needs.checkout.outputs.commit }}-${{ github.run_number }}
                  IMAGE=${{ env.ECR_REGISTRY }}/${{ env.ORDER_SERVICE_REPO }}:$TAG
                  echo "Building image: $IMAGE"
                  docker build -t $IMAGE ./order-service
                  docker push $IMAGE

    update-manifests:
        name: Update K8s Manifests
        runs-on: ubuntu-latest
        needs:
            [
                build-api-gateway,
                build-eureka-server,
                build-user-service,
                build-order-service,
                checkout,
            ]
        if: github.ref == 'refs/heads/master'
        steps:
            - uses: actions/checkout@v4
              with:
                  token: ${{ secrets.GITHUB_TOKEN }}
            - name: Update manifest files
              run: |
                  TAG=${{ needs.checkout.outputs.commit }}-${{ github.run_number }}
                  API_GATEWAY_IMAGE=${{ env.ECR_REGISTRY }}/${{ env.API_GATEWAY_REPO }}:$TAG
                  EUREKA_IMAGE=${{ env.ECR_REGISTRY }}/${{ env.EUREKA_REPO }}:$TAG
                  USER_SERVICE_IMAGE=${{ env.ECR_REGISTRY }}/${{ env.USER_SERVICE_REPO }}:$TAG
                  ORDER_SERVICE_IMAGE=${{ env.ECR_REGISTRY }}/${{ env.ORDER_SERVICE_REPO }}:$TAG

                  echo "Updating manifests with tag: $TAG"

                  sed -i "s|image: .*|image: $API_GATEWAY_IMAGE|" k8s/api-gateway-deployment-service.yaml
                  sed -i "s|image: .*|image: $EUREKA_IMAGE|" k8s/eureka-deployment-service.yaml
                  sed -i "s|image: .*|image: $USER_SERVICE_IMAGE|" k8s/user-deployment-service.yaml
                  sed -i "s|image: .*|image: $ORDER_SERVICE_IMAGE|" k8s/order-deployment-service.yaml

                  git config --local user.email "action@github.com"
                  git config --local user.name "GitHub Action"
                  git add k8s/
                  git commit -m "Update image tags to $TAG" || exit 0
                  git push

    notify-argocd:
        name: Notify ArgoCD for Deployment
        runs-on: ubuntu-latest
        needs: update-manifests
        if: github.ref == 'refs/heads/master'
        steps:
            - name: Trigger ArgoCD Sync
              run: |
                  curl -k -X POST -u ${{ secrets.ARGOCD_USERNAME }}:${{ secrets.ARGOCD_PASSWORD }} \
                  https://${{ secrets.ARGOCD_HOST }}/api/v1/applications/${{ secrets.ARGOCD_APP_NAME }}/sync

    cleanup:
        name: Cleanup Docker Images
        runs-on: ubuntu-latest
        needs: [build-api-gateway, build-eureka-server, build-user-service, build-order-service]
        if: always()
        steps:
            - uses: aws-actions/configure-aws-credentials@v3
              with:
                  role-to-assume: ${{ secrets.AWS_OIDC_ROLE_ARN1 }}
                  aws-region: ${{ secrets.AWS_REGION1 }}
            - name: Delete old ECR images
              run: |
                  aws ecr list-images --repository-name ${{ env.API_GATEWAY_REPO }} --filter tagStatus=UNTAGGED --query 'imageIds[?imageDigest!=null]' --output json | jq '.[]' | aws ecr batch-delete-image --repository-name ${{ env.API_GATEWAY_REPO }} --image-ids file:///dev/stdin || true
                  aws ecr list-images --repository-name ${{ env.EUREKA_REPO }} --filter tagStatus=UNTAGGED --query 'imageIds[?imageDigest!=null]' --output json | jq '.[]' | aws ecr batch-delete-image --repository-name ${{ env.EUREKA_REPO }} --image-ids file:///dev/stdin || true
                  aws ecr list-images --repository-name ${{ env.USER_SERVICE_REPO }} --filter tagStatus=UNTAGGED --query 'imageIds[?imageDigest!=null]' --output json | jq '.[]' | aws ecr batch-delete-image --repository-name ${{ env.USER_SERVICE_REPO }} --image-ids file:///dev/stdin || true
                  aws ecr list-images --repository-name ${{ env.ORDER_SERVICE_REPO }} --filter tagStatus=UNTAGGED --query 'imageIds[?imageDigest!=null]' --output json | jq '.[]' | aws ecr batch-delete-image --repository-name ${{ env.ORDER_SERVICE_REPO }} --image-ids file:///dev/stdin || true
            - name: Delete local Docker images
              run: |
                  docker system prune -af
                  docker image prune -af
