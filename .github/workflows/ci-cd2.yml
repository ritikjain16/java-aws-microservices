name: CI / CD — Build → DevSecOps → ECR → GitOps (ArgoCD)

# Run on push to main (customize branches) and PRs
on:
    push:
        branches: ["master"]
    pull_request:
        branches: ["master"]
    workflow_dispatch:

permissions:
    contents: write
    id-token: write # required for OIDC to AWS
    issues: write
    pull-requests: write

jobs:
    checkout:
        name: Checkout + Cache
        runs-on: ubuntu-latest
        outputs:
            commit: ${{ steps.commit.outputs.sha }}
        steps:
            - name: Checkout repo
              uses: actions/checkout@v4
              with:
                  fetch-depth: 0

            - name: Set commit output
              id: commit
              run: echo "::set-output name=sha::${GITHUB_SHA}"

    # # 3. Static Code Analysis (SonarQube)
    # sonar:
    #     name: SonarQube scan & quality gate
    #     runs-on: ubuntu-latest
    #     needs: checkout
    #     steps:
    #         - name: Setup JDK (Sonar Scanner requirement)
    #           uses: actions/setup-java@v4
    #           with:
    #               distribution: temurin
    #               java-version: "17"

    #         - name: Install Sonar Scanner CLI
    #           run: |
    #               wget https://binaries.sonarsource.com/Distribution/sonar-scanner-cli/sonar-scanner-cli-5.0.1.3006-linux.zip
    #               unzip sonar-scanner-cli-5.0.1.3006-linux.zip
    #               echo "$PWD/sonar-scanner-5.0.1.3006-linux/bin" >> $GITHUB_PATH

    #         - name: Run SonarQube analysis
    #           env:
    #               SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL1 }}
    #               SONAR_TOKEN: ${{ secrets.SONAR_TOKEN1 }}
    #           run: |
    #               # template: adapt to your build tool (mvn/gradle/npm)
    #               sonar-scanner \
    #                   -Dsonar.projectKey=${{ env.APP_NAME }} \
    #                   -Dsonar.host.url=${{ secrets.SONAR_HOST_URL1 }} \
    #                   -Dsonar.login=${{ secrets.SONAR_TOKEN1 }} \
    #                   -Dsonar.inclusions=**/*.js,**/*.ts,**/*.jsx,**/*.css
    #                   # -Dsonar.sources=mern-app-aws-frontend/src \
    #         - name: Wait for SonarQube Quality Gate (fail if gate fails)
    #           env:
    #               SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL1 }}
    #               SONAR_TOKEN: ${{ secrets.SONAR_TOKEN1 }}
    #           run: |
    #               echo "Waiting for SonarQube Quality Gate result..."

    #               # Wait for the analysis report to be processed
    #               analysisId=$(grep 'ceTaskId' .scannerwork/report-task.txt | cut -d'=' -f2)
    #               echo "Analysis ID: $analysisId"

    #               # Poll SonarQube API until the analysis is complete
    #               status="PENDING"
    #               for i in {1..30}; do
    #                   sleep 5
    #                   status=$(curl -s -u $SONAR_TOKEN: "$SONAR_HOST_URL/api/ce/task?id=$analysisId" | jq -r '.task.status')
    #                   echo "Current Status: $status"
    #                   if [ "$status" == "SUCCESS" ]; then
    #                   break
    #                   elif [ "$status" == "FAILED" ]; then
    #                   echo "SonarQube analysis failed."
    #                   exit 1
    #                   fi
    #               done

    #               if [ "$status" != "SUCCESS" ]; then
    #                   echo "SonarQube analysis did not complete in time."
    #                   exit 1
    #               fi

    #               # Fetch Quality Gate result
    #               analysisKey=$(curl -s -u $SONAR_TOKEN: "$SONAR_HOST_URL/api/ce/task?id=$analysisId" | jq -r '.task.analysisId')
    #               echo "Analysis Key: $analysisKey"

    #               qualityGateStatus=$(curl -s -u $SONAR_TOKEN: "$SONAR_HOST_URL/api/qualitygates/project_status?analysisId=$analysisKey" | jq -r '.projectStatus.status')
    #               echo "Quality Gate Status: $qualityGateStatus"

    #               if [ "$qualityGateStatus" != "OK" ]; then
    #                   echo "Quality Gate failed."
    #                   exit 1
    #               else
    #                   echo "Quality Gate passed."
    #               fi

    build-and-push-image:
        name: Build & Push Docker Image to ECR
        runs-on: ubuntu-latest
        needs: checkout
        steps:
            - name: Login to Amazon ECR (uses OIDC / short-lived creds)
              uses: aws-actions/configure-aws-credentials@v3
              with:
                  role-to-assume: ${{ secrets.AWS_OIDC_ROLE_ARN1 }} # least-privilege role configured in AWS for repo
                  aws-region: ${{ secrets.AWS_REGION1 }}

            - name: Login to Amazon ECR
              id: login-ecr
              uses: aws-actions/amazon-ecr-login@v1

            - name: Configure Docker to use ECR credentials
              run: |
                  aws ecr get-login-password --region ${{ secrets.AWS_REGION1 }} | docker login --username AWS --password-stdin ${{secrets.AWS_ACCOUNT_ID1}}.dkr.ecr.${{ secrets.AWS_REGION1 }}.amazonaws.com

            - name: Build, tag, and push image to Amazon ECR
              env:
                  API_GATEWAY_IMAGE_REPO: ${{secrets.AWS_ACCOUNT_ID1}}.dkr.ecr.${{ secrets.AWS_REGION1 }}.amazonaws.com/api-gateway
                  EUREKA_IMAGE_REPO: ${{secrets.AWS_ACCOUNT_ID1}}.dkr.ecr.${{ secrets.AWS_REGION1 }}.amazonaws.com/eureka-server
                  USER_SERVICE_IMAGE_REPO: ${{secrets.AWS_ACCOUNT_ID1}}.dkr.ecr.${{ secrets.AWS_REGION1 }}.amazonaws.com/user-service
                  ORDER_SERVICE_IMAGE_REPO: ${{secrets.AWS_ACCOUNT_ID1}}.dkr.ecr.${{ secrets.AWS_REGION1 }}.amazonaws.com/order-service

                  TAG: ${{ needs.checkout.outputs.commit }}-${{ github.run_number }}
              run: |
                  # Confirm directories
                  echo "Current directory: $(pwd)"
                  ls -l
                  
                  # Build the Api Gateway Docker image
                  docker build -t $API_GATEWAY_IMAGE_REPO:$TAG ./api-gateway/

                  # Build the Eureka Server Docker image
                  docker build -t $EUREKA_IMAGE_REPO:$TAG ./eureka-server/

                  # Build the User Service Docker image
                  docker build -t $USER_SERVICE_IMAGE_REPO:$TAG ./user-service/

                  # Build the Order Service Docker image
                  docker build -t $ORDER_SERVICE_IMAGE_REPO:$TAG ./order-service/

                  # Push the Api Gateway Docker image to ECR
                  docker push $API_GATEWAY_IMAGE_REPO:$TAG

                  # Push the Eureka Server Docker image to ECR
                  docker push $EUREKA_IMAGE_REPO:$TAG

                  # Push the User Service Docker image to ECR
                  docker push $USER_SERVICE_IMAGE_REPO:$TAG

                  # Push the Order Service Docker image to ECR
                  docker push $ORDER_SERVICE_IMAGE_REPO:$TAG
