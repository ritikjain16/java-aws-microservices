name: CI / CD — Build → DevSecOps → ECR → GitOps (ArgoCD)

# Run on push to main (customize branches) and PRs
on:
    push:
        branches: ["master"]
    pull_request:
        branches: ["master"]
    workflow_dispatch:

env:
    API_GATEWAY_REPO: ${{secrets.AWS_ACCOUNT_ID1}}.dkr.ecr.${{ secrets.AWS_REGION1 }}.amazonaws.com/api-gateway
    EUREKA_REPO: ${{secrets.AWS_ACCOUNT_ID1}}.dkr.ecr.${{ secrets.AWS_REGION1 }}.amazonaws.com/eureka-server
    USER_SERVICE_REPO: ${{secrets.AWS_ACCOUNT_ID1}}.dkr.ecr.${{ secrets.AWS_REGION1 }}.amazonaws.com/user-service
    ORDER_SERVICE_REPO: ${{secrets.AWS_ACCOUNT_ID1}}.dkr.ecr.${{ secrets.AWS_REGION1 }}.amazonaws.com/order-service

permissions:
    contents: write
    id-token: write # required for OIDC to AWS
    issues: write
    pull-requests: write

jobs:
    checkout:
        name: Checkout + Cache
        runs-on: ubuntu-latest
        outputs:
            commit: ${{ steps.commit.outputs.sha }}
        steps:
            - name: Checkout repo
              uses: actions/checkout@v4
              with:
                  fetch-depth: 0

            - name: Set commit output
              id: commit
              run: echo "sha=${GITHUB_SHA}" >> $GITHUB_OUTPUT

    # # 3. Static Code Analysis (SonarQube)
    # sonar:
    #     name: SonarQube scan & quality gate
    #     runs-on: ubuntu-latest
    #     needs: checkout
    #     steps:
    #         - name: Setup JDK (Sonar Scanner requirement)
    #           uses: actions/setup-java@v4
    #           with:
    #               distribution: temurin
    #               java-version: "17"

    #         - name: Install Sonar Scanner CLI
    #           run: |
    #               wget https://binaries.sonarsource.com/Distribution/sonar-scanner-cli/sonar-scanner-cli-5.0.1.3006-linux.zip
    #               unzip sonar-scanner-cli-5.0.1.3006-linux.zip
    #               echo "$PWD/sonar-scanner-5.0.1.3006-linux/bin" >> $GITHUB_PATH

    #         - name: Run SonarQube analysis
    #           env:
    #               SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL1 }}
    #               SONAR_TOKEN: ${{ secrets.SONAR_TOKEN1 }}
    #           run: |
    #               # template: adapt to your build tool (mvn/gradle/npm)
    #               sonar-scanner \
    #                   -Dsonar.projectKey=${{ env.APP_NAME }} \
    #                   -Dsonar.host.url=${{ secrets.SONAR_HOST_URL1 }} \
    #                   -Dsonar.login=${{ secrets.SONAR_TOKEN1 }} \
    #                   -Dsonar.inclusions=**/*.js,**/*.ts,**/*.jsx,**/*.css
    #                   # -Dsonar.sources=mern-app-aws-frontend/src \
    #         - name: Wait for SonarQube Quality Gate (fail if gate fails)
    #           env:
    #               SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL1 }}
    #               SONAR_TOKEN: ${{ secrets.SONAR_TOKEN1 }}
    #           run: |
    #               echo "Waiting for SonarQube Quality Gate result..."

    #               # Wait for the analysis report to be processed
    #               analysisId=$(grep 'ceTaskId' .scannerwork/report-task.txt | cut -d'=' -f2)
    #               echo "Analysis ID: $analysisId"

    #               # Poll SonarQube API until the analysis is complete
    #               status="PENDING"
    #               for i in {1..30}; do
    #                   sleep 5
    #                   status=$(curl -s -u $SONAR_TOKEN: "$SONAR_HOST_URL/api/ce/task?id=$analysisId" | jq -r '.task.status')
    #                   echo "Current Status: $status"
    #                   if [ "$status" == "SUCCESS" ]; then
    #                   break
    #                   elif [ "$status" == "FAILED" ]; then
    #                   echo "SonarQube analysis failed."
    #                   exit 1
    #                   fi
    #               done

    #               if [ "$status" != "SUCCESS" ]; then
    #                   echo "SonarQube analysis did not complete in time."
    #                   exit 1
    #               fi

    #               # Fetch Quality Gate result
    #               analysisKey=$(curl -s -u $SONAR_TOKEN: "$SONAR_HOST_URL/api/ce/task?id=$analysisId" | jq -r '.task.analysisId')
    #               echo "Analysis Key: $analysisKey"

    #               qualityGateStatus=$(curl -s -u $SONAR_TOKEN: "$SONAR_HOST_URL/api/qualitygates/project_status?analysisId=$analysisKey" | jq -r '.projectStatus.status')
    #               echo "Quality Gate Status: $qualityGateStatus"

    #               if [ "$qualityGateStatus" != "OK" ]; then
    #                   echo "Quality Gate failed."
    #                   exit 1
    #               else
    #                   echo "Quality Gate passed."
    #               fi

    build-api-gateway:
        name: Build & Push API Gateway
        runs-on: ubuntu-latest
        needs: checkout
        outputs:
            image: ${{ steps.build.outputs.image }}
        steps:
            - uses: actions/checkout@v4
            - uses: aws-actions/configure-aws-credentials@v3
              with:
                  role-to-assume: ${{ secrets.AWS_OIDC_ROLE_ARN1 }}
                  aws-region: ${{ secrets.AWS_REGION1 }}
            - uses: aws-actions/amazon-ecr-login@v1
            - name: Configure Docker to use ECR credentials
              run: |
                  aws ecr get-login-password --region ${{ secrets.AWS_REGION1 }} | docker login --username AWS --password-stdin ${{secrets.AWS_ACCOUNT_ID1}}.dkr.ecr.${{ secrets.AWS_REGION1 }}.amazonaws.com
            - id: build
              run: |
                  TAG=${{ needs.checkout.outputs.commit }}-${{ github.run_number }}
                  IMAGE=${{secrets.AWS_ACCOUNT_ID1}}.dkr.ecr.${{ secrets.AWS_REGION1 }}.amazonaws.com/api-gateway:$TAG
                  echo "Building image: $IMAGE"
                  docker build -t $IMAGE ./api-gateway
                  docker push $IMAGE
                  echo "image=$IMAGE" >> $GITHUB_OUTPUT

    build-eureka-server:
        name: Build & Push Eureka Server
        runs-on: ubuntu-latest
        needs: checkout
        outputs:
            image: ${{ steps.build.outputs.image }}
        steps:
            - uses: actions/checkout@v4
            - uses: aws-actions/configure-aws-credentials@v3
              with:
                  role-to-assume: ${{ secrets.AWS_OIDC_ROLE_ARN1 }}
                  aws-region: ${{ secrets.AWS_REGION1 }}
            - uses: aws-actions/amazon-ecr-login@v1
            - name: Configure Docker to use ECR credentials
              run: |
                  aws ecr get-login-password --region ${{ secrets.AWS_REGION1 }} | docker login --username AWS --password-stdin ${{secrets.AWS_ACCOUNT_ID1}}.dkr.ecr.${{ secrets.AWS_REGION1 }}.amazonaws.com
            - id: build
              run: |
                  TAG=${{ needs.checkout.outputs.commit }}-${{ github.run_number }}
                  IMAGE=${{secrets.AWS_ACCOUNT_ID1}}.dkr.ecr.${{ secrets.AWS_REGION1 }}.amazonaws.com/eureka-server:$TAG
                  echo "Building image: $IMAGE"
                  docker build -t $IMAGE ./eureka-server
                  docker push $IMAGE
                  echo "image=$IMAGE" >> $GITHUB_OUTPUT

    build-user-service:
        name: Build & Push User Service
        runs-on: ubuntu-latest
        needs: checkout
        outputs:
            image: ${{ steps.build.outputs.image }}
        steps:
            - uses: actions/checkout@v4
            - uses: aws-actions/configure-aws-credentials@v3
              with:
                  role-to-assume: ${{ secrets.AWS_OIDC_ROLE_ARN1 }}
                  aws-region: ${{ secrets.AWS_REGION1 }}
            - uses: aws-actions/amazon-ecr-login@v1
            - name: Configure Docker to use ECR credentials
              run: |
                  aws ecr get-login-password --region ${{ secrets.AWS_REGION1 }} | docker login --username AWS --password-stdin ${{secrets.AWS_ACCOUNT_ID1}}.dkr.ecr.${{ secrets.AWS_REGION1 }}.amazonaws.com
            - id: build
              run: |
                  TAG=${{ needs.checkout.outputs.commit }}-${{ github.run_number }}
                  IMAGE=${{secrets.AWS_ACCOUNT_ID1}}.dkr.ecr.${{ secrets.AWS_REGION1 }}.amazonaws.com/user-service:$TAG
                  echo "Building image: $IMAGE"
                  docker build -t $IMAGE ./user-service
                  docker push $IMAGE
                  echo "image=$IMAGE" >> $GITHUB_OUTPUT

    build-order-service:
        name: Build & Push Order Service
        runs-on: ubuntu-latest
        needs: checkout
        outputs:
            image: ${{ steps.build.outputs.image }}
        steps:
            - uses: actions/checkout@v4
            - uses: aws-actions/configure-aws-credentials@v3
              with:
                  role-to-assume: ${{ secrets.AWS_OIDC_ROLE_ARN1 }}
                  aws-region: ${{ secrets.AWS_REGION1 }}
            - uses: aws-actions/amazon-ecr-login@v1
            - name: Configure Docker to use ECR credentials
              run: |
                  aws ecr get-login-password --region ${{ secrets.AWS_REGION1 }} | docker login --username AWS --password-stdin ${{secrets.AWS_ACCOUNT_ID1}}.dkr.ecr.${{ secrets.AWS_REGION1 }}.amazonaws.com
            - id: build
              run: |
                  TAG=${{ needs.checkout.outputs.commit }}-${{ github.run_number }}
                  IMAGE=${{secrets.AWS_ACCOUNT_ID1}}.dkr.ecr.${{ secrets.AWS_REGION1 }}.amazonaws.com/order-service:$TAG
                  echo "Building image: $IMAGE"
                  docker build -t $IMAGE ./order-service
                  docker push $IMAGE
                  echo "image=$IMAGE" >> $GITHUB_OUTPUT

    update-manifests:
        name: Update K8s Manifests
        runs-on: ubuntu-latest
        needs: [build-api-gateway, build-eureka-server, build-user-service, build-order-service]
        if: github.ref == 'refs/heads/master'
        steps:
            - uses: actions/checkout@v4
              with:
                  token: ${{ secrets.GITHUB_TOKEN }}
            - name: Update manifest files
              env:
                  API_GATEWAY_IMAGE: ${{ needs.build-api-gateway.outputs.image }}
                  EUREKA_IMAGE: ${{ needs.build-eureka-server.outputs.image }}
                  USER_SERVICE_IMAGE: ${{ needs.build-user-service.outputs.image }}
                  ORDER_SERVICE_IMAGE: ${{ needs.build-order-service.outputs.image }}
              run: |
                  echo "API Gateway Image: $API_GATEWAY_IMAGE"
                  echo "Eureka Image: $EUREKA_IMAGE"
                  echo "User Service Image: $USER_SERVICE_IMAGE"
                  echo "Order Service Image: $ORDER_SERVICE_IMAGE"
                  
                  sed -i "s|image: .*api-gateway:.*|image: $API_GATEWAY_IMAGE|" k8s/api-gateway-deployment-service.yaml
                  sed -i "s|image: .*eureka-server:.*|image: $EUREKA_IMAGE|" k8s/eureka-deployment-service.yaml
                  sed -i "s|image: .*user-service:.*|image: $USER_SERVICE_IMAGE|" k8s/user-deployment-service.yaml
                  sed -i "s|image: .*order-service:.*|image: $ORDER_SERVICE_IMAGE|" k8s/order-deployment-service.yaml
                  
                  git config --local user.email "action@github.com"
                  git config --local user.name "GitHub Action"
                  git add k8s/
                  git commit -m "Update image tags to ${{ needs.checkout.outputs.commit }}-${{ github.run_number }}" || exit 0
                  git push
